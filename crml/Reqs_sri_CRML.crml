// SRI requirement model
model Reqs_sri_CRML is {

   // ETL library

	// Operators on Boolean
	// Logical disjunction
	Template b1 'or' b2 = not (not b1 and not b2);

	// Exclusive logical disjunction
	Template b1 'xor' b2 = (b1 'or' b2) and not (b1 and b2);
  
	// Logical inference
	Template b1 'implies' b2 = not b1 'or' b2;

	// Operators on clocks
	// Filter clock ticks inside a time period
	Operator [ Clock ] Clock C 'inside' Period P 
		= C filter ((tick C >= P start) and (tick C <= P end));
  
	// Count the occurrences of events inside a time period
	Operator [ Integer ] 'count' Clock C 'inside' Period P = card (C 'inside' P);
  
	// Operators on events
	// Events generated when a Boolean becomes true
	Operator [ Clock ] Boolean b 'becomes true' = new Clock b;
  
	// Events generated when a Boolean becomes false
	Operator [ Clock] Boolean b 'becomes false' = not b 'becomes true';

	// Events generated when a Boolean becomes true inside a time period
	Operator [ Clock] Boolean b 'becomes true inside' Period P 
		= (b 'becomes true') 'inside' P;

	// Events generated when a Boolean becomes false inside a time period
	Operator [ Clock] Boolean b 'becomes false inside' Period P 
		= (b 'becomes false') 'inside' P; 

	// Decide
	// Operator 'decide' is 
	Operator [ Boolean ] 'decide' Boolean phi 'over' Period P 
        = phi 'or' new Boolean (P end);

	// Evaluate
	Operator [ Boolean ] 'evaluate' Boolean phi 'over' Period P 
		= integrate (('decide' phi 'over' P) * phi) on P;

	// Operators for the evaluation of requirements
	// Check
	Operator [ Boolean ] 'check' Boolean phi 'over' Periods P 
		= and ('evaluate' phi 'over' P);
    
	Category increasing_int = { (>, >), (>=, >=), (<, >=), (<=, >), (==, >), (<>, >) };
	Category increasing_real = { (>, >), (>=, >=), (<, >=), (<=, >) };
	Operator [ Boolean ]  Integer x '>_int' Integer n = apply increasing_int on ( x > n );
	Operator [ Boolean ]  Integer x '>=_int' Integer n = apply increasing_int on ( x >= n );
	Operator [ Boolean ]  Integer x '<_int' Integer n = apply increasing_int on ( x < n );
	Operator [ Boolean ]  Integer x '<=_int' Integer n = apply increasing_int on ( x <= n );
	Operator [ Boolean ]  Integer x '==_int' Integer n = apply increasing_int on ( x == n );
	Operator [ Boolean ]  Integer x '<>_int' Integer n = apply increasing_int on ( x <> n );
	Operator [ Boolean ]  Real x '>_real' Real d = apply increasing_real on ( x > d );
	Operator [ Boolean ]  Real x '>=_real' Real d = apply increasing_real on ( x >= d );
	Operator [ Boolean ]  Real x '<_real' Real d = apply increasing_real on ( x < d );
	Operator [ Boolean ]  Real x '<=_real' Real d = apply increasing_real on ( x <= d );


    Operator [ Boolean ] 'id' Boolean b = b;
	Operator [ Boolean ] 'cte_false' Boolean b = false;
	Operator [ Boolean ] 'cte_true' Boolean b = true;

    Category varying1 = { ('id', 'cte_false') };
    Category varying2 = { ('id', 'cte_true') };
    Operator [ Boolean ] 'set to false' Boolean b = apply varying1 on ( 'id' b ); 
    Operator [ Boolean ] 'set to true' Boolean b = apply varying2 on ( 'id' b ); 

	///////////////////////////////////////////////////////////////////////////////
	// FORM-L library
    // include "ETL.crml"

	// Operators to define time periods
	// From events occur
	Operator [ Periods ] 'from' Clock ev = new Periods [ ev, new Clock false ]; 
	
	// After events occur
	Operator [ Periods ] 'after' Clock ev = new Periods ] ev, new Clock false ]; 
	
	// Before events occur
	Operator [ Periods ] 'before' Clock ev = new Periods [ new Clock false, ev [; 
	
	// Until events occur
	Operator [ Periods ] 'until' Clock ev = new Periods [ new Clock false, ev ]; 
	
	// While a Boolean is true
	Operator [ Periods ] 'during' Boolean b = new Periods [ new Clock b, new Clock not b ]; 
	
	// After events occur and before events occur
	Operator [ Periods ] 'after' Clock ev1 'before' Clock ev2 = new Periods ] ev1, ev2 [; 
	
	// After events occur and until events occur
	Operator [ Periods ] 'after' Clock ev1 'until' Clock ev2 = new Periods ] ev1, ev2 ]; 
	
	// After events occur and for an elapsed time
	Operator [ Periods ] 'after' Clock ev 'for' Real d = new Periods ] ev, ev + d ]; 
	
	// After events occur and within an elapsed time
	Operator [ Periods ] 'after' Clock ev 'within' Real d = new Periods ] ev, ev + d [; 
	
	// From events occur and before events occur
	Operator [ Periods ] 'from' Clock ev1 'before' Clock ev2 = new Periods [ ev1, ev2 [; 
	
	// From events occur and until events occur
	Operator [ Periods ] 'from' Clock ev1 'until' Clock ev2 = new Periods [ ev1, ev2 ]; 
	
	// From events occur and for an elapsed time
	Operator [ Periods ] 'from' Clock ev 'for' Real d = new Periods [ ev, ev + d ]; 
	
	// From events occur and within an elapsed time
	Operator [ Periods ] 'from' Clock ev 'within' Real d = new Periods [ ev, ev + d [; 
	
	// When events occurs
	Operator [ Periods ] 'when' Clock ev = new Periods [ ev, ev ];


	// Operators for the evaluation of requirements
	
	// Checking that a requirement is satisfied at the end of a time period
	Operator [ Boolean ] Periods P 'check at end' Boolean b 
        = 'check' ('set to false' b) 'over' P;
	
	// Checking that a requirement is satisfied at any time instant of a time period
	Operator [ Boolean ] Periods P 'check anytime' Boolean b 
        = 'check' ('set to true' b) 'over' P;
		
    // Following operators cannot be implemented because "count inside" is implemented only on period and not periods (which would have no meaning) !
  
	// Checking that the number of event occurrences at the end of a time period is lower or higher than a threshold
	//Operator [ Boolean ] Periods P 'check count' Clock E '<' Integer n 
	//	= 'check' (('count' E 'inside' P) '<_int' n) 'over' P;
	//Operator [ Boolean ] Periods P 'check count' Clock E '<=' Integer n 
	//	= 'check'(('count' E 'inside' P) '<=_int' n) 'over' P;
	//Operator [ Boolean ] Periods P 'check count' Clock E '>' Integer n 
	//	= 'check'(('count' E 'inside' P) '>_int' n) 'over' P;
	//Operator [ Boolean ] Periods P 'check count' Clock E '>=' Integer n 
	//	= 'check'(('count' E 'inside' P) '>=_int' n) 'over' P;
	//Operator [ Boolean ] Periods P 'check count' Clock E '==' Integer n 
	//	= 'check'(('count' E 'inside' P) '==_int' n) 'over' P;
	//Operator [ Boolean ] Periods P 'check count' Clock E '<>' Integer n 
	//	= 'check'(('count' E 'inside' P) '<>_int' n) 'over' P;
    
	// Ensuring that a requirement is satisfied all along a time period
	//Operator [ Boolean ] Periods P 'ensure' Boolean b 
	//	= (P 'check count' (b 'becomes true') '==' 0) and (P 'check anytime' b);


    // Following operators cannot been implemented because "duration on" is not implemented yet in the compiler.
    
	// Checking that the duration of a condition at the end of a time period is lower or higher than a threshold 
	//Operator [ Boolean ] Periods P 'check duration' Boolean b '<' Real d 
	//	= 'check' (('duration' b 'on' P) '<_real' d) 'over' P;
	//Operator [ Boolean ] Periods P 'check duration' Boolean b '<=' Real d 
	//	= 'check' (('duration' b 'on' P) '<=_real' d) 'over' P;
	//Operator [ Boolean ] Periods P 'check duration' Boolean b '>' Real d 
	//	= 'check' (('duration' b 'on' P) '>_real' d) 'over' P;
	//Operator [ Boolean ] Periods P 'check duration' Boolean b '>=' Real d 
	//	= 'check' (('duration' b 'on' P) '>=_real' d) 'over' P;
	
	///////////////////////////////////////////////////////////////////////////////
	// Finally, the SRI model
	
	// Always
	Operator [ Periods ] 'always' = 'during' true; 

	// Temperature import	
	
	// R1 : "La température du SRI doit être maintenue entre 16°C et 30°C."

	// R2 : "Si la température dépasse ces limites, elle doit être revenue dans l'intervalle au bout d'une minute."

